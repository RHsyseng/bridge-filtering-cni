#!/bin/bash -e

if [[ ${DEBUG} -gt 0 ]]; then set -x; fi

exec 3>&1
exec &>> /tmp/bash-cni-plugin.log

stdin=`cat /dev/stdin`
tmpfile="/tmp/bash-cni-plugin.log"

NFT_CHAIN=prerouting
NFT_HOOK=prerouting
NFT_TABLE_TYPE=bridge
NFT_TABLE=filter

# Loops over a array in json config $1. The array path is specified in $2.
# Calls a function $3 for each object in the array. 
for_json_array() {
    add_rule_for=$3
    _extract_array() {
        echo $1 | jq -c $2 | jq -c '.[]'
    }
    for ip_range in $(_extract_array $1 $2); do
        echo "$add_rule_for $ip_range"
        $add_rule_for $ip_range
    done
}

# returns string in format <address>/<mask> for given CIDR range
# parameters
# $1 json string with cidr struct
ip_from_json_to_str_with_mask () {
    ip=$(echo $1 | jq -r .ip)
    prefix=$(echo $1 | jq -r '."prefix-length"')
    echo "${ip}/${prefix}"
}

# returns ip or ip6
# parameters
# $1 <string> ip address
get_ip_version() {
    if [[ $1 =~ .*:.* ]]
    then 
        echo "ip6"
    else
        echo "ip" 
    fi
}

create_table() {
    ip netns exec $CNI_CONTAINERID nft add table $1 $2
}

create_table_chain() {
    ip netns exec $CNI_CONTAINERID nft add chain $1 $2 $3 {type filter hook ${NFT_HOOK} priority 0\; policy drop \;}
}

nft_add_rule() {
    type="$1"
    table="$2"
    chain="$3"
    set -- "${@:4}"
    nft add rule $type $table $chain $@
}

allow_arp() {
    ip netns exec $CNI_CONTAINERID nft add rule bridge $1 $2 ether type arp counter accept
}

create_ingress_rule() {
    ip_address=$(ip_from_json_to_str_with_mask $1)
    nft_cmd="nft add rule ${NFT_TABLE_TYPE} ${NFT_TABLE} ${NFT_CHAIN} iifname $CNI_IFNAME $(get_ip_version ${ip_address}) saddr ${ip_address} counter accept"
    echo "command: ip netns exec $CNI_CONTAINERID ${nft_cmd}"
    ip netns exec $CNI_CONTAINERID ${nft_cmd}

}

create_egress_rule() {
    ip_address=$(ip_from_json_to_str_with_mask $1)
    nft_cmd="nft add rule ${NFT_TABLE_TYPE} ${NFT_TABLE} ${NFT_CHAIN} iifname $CNI_IFNAME $(get_ip_version ${ip_address}) daddr ${ip_address} counter accept"
    echo "command: ip netns exec $CNI_CONTAINERID ${nft_cmd}"
    ip netns exec $CNI_CONTAINERID ${nft_cmd}
}

case $CNI_COMMAND in
ADD)
    echo "CNI_NETNS: $CNI_NETNS" >> $tmpfile
    echo "CNI_IFNAME: $CNI_IFNAME" >> $tmpfile
    echo "CNI_CONTAINERID: $CNI_CONTAINERID" >> $tmpfile

    mkdir -p /var/run/netns/
    ln -sfT $CNI_NETNS /var/run/netns/$CNI_CONTAINERID

    ip netns exec $CNI_CONTAINERID ip a >> $tmpfile
    create_table ${NFT_TABLE_TYPE} ${NFT_TABLE}
    create_table_chain ${NFT_TABLE_TYPE} ${NFT_TABLE} ${NFT_CHAIN}

    nft_add_rule ${NFT_TABLE_TYPE} ${NFT_TABLE} ${NFT_CHAIN} ether type arp counter accept
    
    for_json_array $stdin '.ingress' create_ingress_rule
    for_json_array $stdin '.egress' create_egress_rule

    # echo empty response, since we haven't changed interfaces/routes
    echo "{
  \"cniVersion\": \"$(jq -r ".cniVersion" <<< "$stdin")\"
}" >&3
    exit 0
;;

DEL)
    echo "Delete $CNI_CONTAINERID"
    rm -f /var/run/netns/"$CNI_CONTAINERID"
;;

VERSION)
    echo '{"cniVersion":"0.3.1","supportedVersions":["0.1.0","0.2.0","0.3.0","0.3.1"]}' >&3
;;

*)
    exit 0
;;

esac

#!/bin/bash

set -euo pipefail

stdin=$(cat /dev/stdin)
logFile="${LOGFILE:-/var/log/bridge-filtering.log}"

KUBECONFIG_PATH="${KUBECONFIG_PATH:-/etc/cni/net.d/bridge-filtering.d/bridge-filtering.kubeconfig}"
CNI_VERSION="$(echo "$stdin" | jq -r ".cniVersion")"
CNI_PREV_RESULT="$(echo "$stdin" | jq -cr ".prevResult")"

exec 2>> $logFile

NFT_BRIDGE_TABLE=bridge
NFT_TABLE=filter

NFT_INGRESS_CHAIN=prerouting
NFT_INGRESS_HOOK=prerouting

NFT_POSTROUTING_CHAIN=postrouting
NFT_EGRESS_HOOK=postrouting

get_object() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -cr "$json_path"
}

get_array_items() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -c $json_path | jq -cr ".[]"
}

get_array_len() {
    local json_object="$1"
    local json_path="$2"
    echo "$json_object" | jq -c "$json_path" | jq ". | length"
}

for_json_array() {
    local json_object="$1"
    local json_path="$2"
    local fn="$3"
    for item in $(get_array_items "$json_object" "$json_path"); do
        $fn $item
    done
}

get_ip_version() {
    local ip_address="$1"
    if [[ "$ip_address" =~ .*:.* ]]
    then
        echo "ip6"
    else
        echo "ip"
    fi
}

create_table() {
    local type="$1"
    local name="$2"
    echo "nft add table $type $name" | tee -a $logFile
}

create_netdev_base_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    local hook="$4"
    local device="$5"
    echo "nft add chain $type $name $chain { type filter hook $hook device $device priority -1; policy accept; }" | tee -a $logFile
}

create_base_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    local hook="$4"
    echo "nft add chain $type $name $chain { type filter hook $hook priority -1; policy accept; }" | tee -a $logFile
}

create_chain() {
    local type="$1"
    local name="$2"
    local chain="$3"
    echo "nft add chain $type $name $chain" | tee -a $logFile
}

nft_add_rule() {
    local type="$1"
    local table="$2"
    local chain="$3"
    set -- "${@:4}"
    echo "nft add rule $type $table $chain $@" | tee -a $logFile
}

create_rules_for_filtering() {
    local config_id="$1"
    local config="$2"
    local table_type="$3"
    local direction="$4"

    local match_addr="saddr"
    if [[ "$direction" == "egress" ]]; then
        local match_addr="daddr"
    fi
    local match_iface="iifname"
    if [[ "$direction" == "egress" ]]; then
        match_iface="oifname"
    fi

    _create_filtering_chain() {
        local config_id="$1"
        local config="$2"
        local table_type="$3"
        local direction="$4"
        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}") || exitWithError "${CNI_VERSION}" "Failed to add chain "${CNI_IFNAME}"-${config_id}-${direction}"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${direction}" "${match_iface}" "$CNI_IFNAME" counter jump "${CNI_IFNAME}"-"${config_id}"-"${direction}") || exitWithError "${CNI_VERSION}" "Failed to add rule: jump "${CNI_IFNAME}"-${config_id}-${direction}"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}" counter meta mark set meta mark "&" 0xfffcffff) || exitWithError "${CNI_VERSION}" "Failed to add rule: set meta mark & 0xfffcffff"
    }

    _create_subnet_rule() {
        local subnet=$1
        if [[ "$(get_object "${subnet}" ".except")" != "null" ]]; then
            for_json_array "${subnet}" ".except" _drop_subnet
        fi

        if [[ "$(get_object "${subnet}" ".cidr")" == "null" || "$(get_object "${subnet}" ".cidr")" == "" ]]; then
            ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-subnets ${match_iface} $CNI_IFNAME counter meta mark set mark or 0x20000) ||  exitWithError "${CNI_VERSION}" "Failed to add rule to allow all subnets in chain: ${CNI_IFNAME}-${config_id}-${direction}-subnets"
        else
            _accept_cidr "${subnet}"
        fi
    }

    _drop_subnet() {
        local subnet="$1"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-subnets ${match_iface} $CNI_IFNAME $(get_ip_version "${subnet}") ${match_addr} ${subnet} counter drop) ||  exitWithError "${CNI_VERSION}" "Failed to drop subnet ${subnet} in chain: ${CNI_IFNAME}-${config_id}-${direction}-subnets"
    }

    _accept_cidr() {
        local subnet="$1"
        local cidr=$(echo "${subnet}" | jq -r ".cidr")
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-subnets ${match_iface} $CNI_IFNAME $(get_ip_version "${cidr}") ${match_addr} ${cidr} counter meta mark set mark or 0x20000) ||  exitWithError "${CNI_VERSION}" "Failed to allow cidr ${cidr} in chain: ${CNI_IFNAME}-${config_id}-${direction}-subnets"
    }

    _accept_port() {
        local ports="$1"
        local port=$(echo "$ports" | jq -r ".port")
        local protocol=$(echo "$ports" | jq -r ".protocol")

        if [[ "$port" == "null" || "$port" == "" ]]; then
            if [[ "$protocol" == "null" || "$protocol" == "" ]]; then
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow all ports on all protocols in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
            else
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME ip protocol ${protocol,,} counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow all ports on ipv4 ${protocol} in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME ip6 nexthdr ${protocol,,} counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow all ports on ipv6 ${protocol} in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
            fi
        else
            if [[ "$protocol" == "null" || "$protocol" == "" ]]; then
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME tcp dport ${port} counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow port(s) ${port} on tcp in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME udp dport ${port} counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow port(s) ${port} on udp in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
            else
                ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${table_type} ${NFT_TABLE} "${CNI_IFNAME}"-${config_id}-${direction}-ports ${match_iface} $CNI_IFNAME ${protocol,,} dport ${port} counter meta mark set meta mark "|" 0x00010000) ||  exitWithError "${CNI_VERSION}" "Failed to allow port(s) ${port} on ${protocol} in chain: ${CNI_IFNAME}-${config_id}-${direction}-ports"
            fi
        fi
    }

    local is_filtering_chain_created=false
    if [[ $(echo "$config" | jq -r ".${direction}.subnets") != "null" || $(echo "$config" | jq -r ".${direction}.ports") != "null" ]]; then
        _create_filtering_chain "${config_id}" "${config}" "${table_type}" "${direction}"
        is_filtering_chain_created=true
    fi

    # handle ip subnet
    if [[ $(echo "$config" | jq -r ".${direction}.subnets") != "null" && $(get_array_len "$config" ".${direction}.subnets") > 0 ]]; then

        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}"-subnets) || exitWithError "${CNI_VERSION}" "Failed to add chain "${CNI_IFNAME}"-"${config_id}"-"${direction}"-subnets"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}" counter jump "${CNI_IFNAME}"-"${config_id}"-"${direction}"-subnets) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump "${CNI_IFNAME}"-"${config_id}"-"${direction}"-subnets"

        for_json_array "$config" ".${direction}.subnets" _create_subnet_rule
    fi

    # handle ports
    if [[ $(echo "$config" | jq -r ".${direction}.ports") != "null" && $(get_array_len "$config" ".${direction}.ports") > 0 ]]; then
        ip netns exec "$CNI_CONTAINERID" $(create_chain "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}"-ports) || exitWithError "${CNI_VERSION}" "Failed to add chain "${CNI_IFNAME}"-"${config_id}"-"${direction}"-ports"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}" counter jump "${CNI_IFNAME}"-"${config_id}"-"${direction}"-ports) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump "${CNI_IFNAME}"-"${config_id}"-"${direction}"-ports"
        
        for_json_array "$config" ".${direction}.ports" _accept_port
    fi

    if [[ "$is_filtering_chain_created" == true ]]; then
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${table_type}" "${NFT_TABLE}" "${CNI_IFNAME}"-"${config_id}"-"${direction}" meta mark "&" 0x00030000 == 0x00030000 counter accept) || exitWithError "${CNI_VERSION}" "Failed to add rule: mark & 0x00030000 == 0x00030000 counter accept"
    fi
}

exitWithError() {
    local cni_version="$1"
    local message="${2:-""}"
    local details="${3:-""}"
    echo "{\"cniVersion\": \"${cni_version}\",\"msg\":\"${message}\",\"code\":101,\"details\":\"${details}\"}"
    exit 1
}

exitWithSuccess() {
    local cni_version="$1"
    local prev_result="$2"
    if [[ "$prev_result" == "null" ]]; then
        echo "{\"cniVersion\": \"$cni_version\"}"
    else
        echo "$prev_result"
    fi
    exit 0
}

main() {
    case $CNI_COMMAND in
    ADD)
        echo "CNI_NETNS: $CNI_NETNS" >> $logFile
        echo "CNI_CONTAINERID: $CNI_CONTAINERID" >> $logFile
        echo "STDIN: $stdin" >> $logFile
        echo "CNI_ARGS: $CNI_ARGS" >> $logFile

        local cidr_filtering_cni_label="bridge-filtering"
        local cni_spec_name=$(echo "$stdin" | jq -r ".name")
        local pod_namespace=""

        for i in ${CNI_ARGS//;/ }
        do
            case $i in
            "K8S_POD_NAMESPACE="*)
                pod_namespace=$(echo $i | awk -F'=' '{print $2}')
                if [[ "$pod_namespace" == "" ]]; then
                    exitWithError "${CNI_VERSION}" "Failed to parse pod namespace from CNI_ARGS"
                fi
            ;;
            esac
        done

        mkdir -p /var/run/netns/
        ln -sfT "$CNI_NETNS" /var/run/netns/"${CNI_CONTAINERID}"

        # Check API access
        kubectl --kubeconfig=${KUBECONFIG_PATH} api-resources > /dev/null || exitWithError "${CNI_VERSION}" "Failed to reach kubernetes API server" "kubeconfig path: $KUBECONFIG_PATH"

        ip netns exec "$CNI_CONTAINERID" $(create_table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}) || exitWithError "${CNI_VERSION}" "Failed to create table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}"
        ip netns exec "$CNI_CONTAINERID" $(create_table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}) || exitWithError "${CNI_VERSION}" "Failed to create table ${NFT_BRIDGE_TABLE} ${NFT_TABLE}"

        # create base chains
        ip netns exec "$CNI_CONTAINERID" $(create_base_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} ${NFT_INGRESS_HOOK}) || exitWithError "${CNI_VERSION}" "Failed to create base chain ${NFT_INGRESS_CHAIN}"
        ip netns exec "$CNI_CONTAINERID" $(create_base_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} ${NFT_EGRESS_HOOK}) || exitWithError "${CNI_VERSION}" "Failed to create bridge base chain ${NFT_POSTROUTING_CHAIN}"

        # filter chains
        ip netns exec "$CNI_CONTAINERID" $(create_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} "${CNI_IFNAME}"-ingress) || exitWithError "${CNI_VERSION}" "Failed to add chain "${CNI_IFNAME}"-ingress"
        ip netns exec "$CNI_CONTAINERID" $(create_chain ${NFT_BRIDGE_TABLE} ${NFT_TABLE} "${CNI_IFNAME}"-egress) || exitWithError "${CNI_VERSION}" "Failed to add chain "${CNI_IFNAME}"-egress"

        # setup prerouting chain
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} ether type arp counter accept) || exitWithError "${CNI_VERSION}" "Failed to allow arp for ingress"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_INGRESS_CHAIN} iifname $CNI_IFNAME counter jump "${CNI_IFNAME}"-ingress) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump "${CNI_IFNAME}"-ingress"

        # setup postrouting chain
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} ether type arp counter accept) || exitWithError "${CNI_VERSION}" "Failed to allow arp for egress"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule ${NFT_BRIDGE_TABLE} ${NFT_TABLE} ${NFT_POSTROUTING_CHAIN} oifname $CNI_IFNAME counter jump "${CNI_IFNAME}"-egress) || exitWithError "${CNI_VERSION}" "Failed to add rule: jump "${CNI_IFNAME}"-egress"

        _process_configmap() {
            local configmap_name="$1"
            local configmap_namespace="$2"
            local config_id="$(echo "${configmap_name}${configmap_namespace}" | sha1sum )"
            config_id="${config_id:0:5}" # use first 5 characters to identify configuration specified in a configmap

            # the json config in configmap is escaped when the configmap itself is obtained in json. To be able to work with it with jq, we need to remove '\n', '\'', spaces and leading/trailing character (which is an apostrophe)
            local config=$(kubectl --kubeconfig=${KUBECONFIG_PATH} get cm ${configmap_name} -n ${configmap_namespace} -o json | jq -c '.data."config.json"' | sed 's#\\n##g;s#\\##g;s# ##g;s/^.//;s/.$//')

            create_rules_for_filtering "$config_id" "$config" "${NFT_BRIDGE_TABLE}" "ingress"
            create_rules_for_filtering "$config_id" "$config" "${NFT_BRIDGE_TABLE}" "egress"
        }
        
        for configmap_name in $(kubectl --kubeconfig=${KUBECONFIG_PATH} get cm -l${cni_spec_name},${cidr_filtering_cni_label} -n ${pod_namespace} -o jsonpath='{range .items[*]}{@.metadata.name}{"\n"}' | head -n -1); do
            _process_configmap $configmap_name $pod_namespace
        done

        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" "${CNI_IFNAME}"-ingress counter drop) || exitWithError "${CNI_VERSION}" "Failed to add rule: drop"
        ip netns exec "$CNI_CONTAINERID" $(nft_add_rule "${NFT_BRIDGE_TABLE}" "${NFT_TABLE}" "${CNI_IFNAME}"-egress counter drop) || exitWithError "${CNI_VERSION}" "Failed to add rule: drop"

        exitWithSuccess "${CNI_VERSION}" "${CNI_PREV_RESULT}"
    ;;

    DEL)
        echo "Delete $CNI_CONTAINERID" >> $logFile
        rm -f /var/run/netns/"$CNI_CONTAINERID"
    ;;

    VERSION)
        echo "{\"cniVersion\":\"0.3.1\",\"supportedVersions\":[\"0.1.0\",\"0.2.0\",\"0.3.0\",\"0.3.1\"]}"
    ;;

    *)
        exitWithError "${CNI_VERSION}" "Unrecognized CNI command: ${CNI_COMMAND}"
    ;;

    esac
}

main
